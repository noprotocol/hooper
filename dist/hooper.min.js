var t, i;
(t = this),
  (i = function(t, i) {
    'use strict';
    function d(t, i, e) {
      return (
        i in t ? Object.defineProperty(t, i, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : (t[i] = e),
        t
      );
    }
    function r(i, t) {
      var e,
        r = Object.keys(i);
      return (
        Object.getOwnPropertySymbols &&
          ((e = Object.getOwnPropertySymbols(i)),
          t &&
            (e = e.filter(function(t) {
              return Object.getOwnPropertyDescriptor(i, t).enumerable;
            })),
          r.push.apply(r, e)),
        r
      );
    }
    function h(i) {
      for (var t = 1; t < arguments.length; t++) {
        var e = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? r(Object(e), !0).forEach(function(t) {
              d(i, t, e[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e))
          : r(Object(e)).forEach(function(t) {
              Object.defineProperty(i, t, Object.getOwnPropertyDescriptor(e, t));
            });
      }
      return i;
    }
    function c(t) {
      return (
        (function(t) {
          if (Array.isArray(t)) return n(t);
        })(t) ||
        (function(t) {
          if ('undefined' != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);
        })(t) ||
        (function(t, i) {
          if (!t) return;
          if ('string' == typeof t) return n(t, i);
          var e = Object.prototype.toString.call(t).slice(8, -1);
          'Object' === e && t.constructor && (e = t.constructor.name);
          if ('Map' === e || 'Set' === e) return Array.from(t);
          if ('Arguments' === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return n(t, i);
        })(t) ||
        (function() {
          throw new TypeError(
            'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
          );
        })()
      );
    }
    function n(t, i) {
      (null == i || i > t.length) && (i = t.length);
      for (var e = 0, r = new Array(i); e < i; e++) r[e] = t[e];
      return r;
    }
    function o() {
      return Date.now();
    }
    function e(e, r) {
      (this.create = function() {
        return window.setTimeout(e, r);
      }),
        (this.stop = function() {
          this.timer && (window.clearTimeout(this.timer), (this.timer = null));
        }),
        (this.start = function() {
          this.timer || (this.timer = this.create());
        }),
        (this.set = function(t) {
          var i = t || r;
          this.timer = window.setTimeout(e, i);
        }),
        (this.timer = this.create());
    }
    function p(t, i) {
      var e = t < 0 ? (t + i) % i : t % i;
      return e != e ? 0 : e;
    }
    function u(t, i) {
      var e = i.children || i.componentOptions.children || i.text;
      return t(i.componentOptions.Ctor, i.data, e);
    }
    i = i && Object.prototype.hasOwnProperty.call(i, 'default') ? i.default : i;
    var s =
      Object.assign ||
      function(t) {
        if (null == t) throw new TypeError('Cannot convert first argument to object');
        for (var i = Object(t), e = 1; e < arguments.length; e++) {
          var r = arguments[e];
          if (null != r) {
            r = Object(r);
            for (var n = Object.keys(Object(r)), o = 0, s = n.length; o < s; o++) {
              var a = n[o],
                h = Object.getOwnPropertyDescriptor(r, a);
              void 0 !== h && h.enumerable && (i[a] = r[a]);
            }
          }
        }
        return i;
      };
    var a =
      Math.sign ||
      function(t) {
        return t < 0 ? -1 : 0 < t ? 1 : 0;
      };
    function l(t, i) {
      var e = 1 < arguments.length && void 0 !== i ? i : {};
      return t.$scopedSlots.default ? t.$scopedSlots.default(e) || [] : t.$slots.default || [];
    }
    var f = new i(),
      g = {
        name: 'Hooper',
        provide: function() {
          return { $hooper: this };
        },
        props: {
          itemsToShow: { default: 1, type: Number },
          itemsToSlide: { default: 1, type: Number },
          initialSlide: { default: 0, type: Number },
          infiniteScroll: { default: !1, type: Boolean },
          centerMode: { default: !1, type: Boolean },
          vertical: { default: !1, type: Boolean },
          rtl: { default: null, type: Boolean },
          autoPlay: { default: !1, type: Boolean },
          playSpeed: { default: 2e3, type: Number },
          mouseDrag: { default: !0, type: Boolean },
          touchDrag: { default: !0, type: Boolean },
          wheelControl: { default: !0, type: Boolean },
          keysControl: { default: !0, type: Boolean },
          shortDrag: { default: !0, type: Boolean },
          transition: { default: 300, type: Number },
          hoverPause: { default: !0, type: Boolean },
          trimWhiteSpace: { default: !1, type: Boolean },
          settings: {
            default: function() {
              return {};
            },
            type: Object
          },
          group: { type: String, default: null }
        },
        data: function() {
          return {
            isDragging: !1,
            isSliding: !1,
            isTouch: !1,
            isHover: !1,
            isFocus: !1,
            initialized: !1,
            slideWidth: 0,
            slideHeight: 0,
            slidesCount: 0,
            trimStart: 0,
            trimEnd: 1,
            currentSlide: null,
            timer: null,
            defaults: {},
            breakpoints: {},
            delta: { x: 0, y: 0 },
            config: {}
          };
        },
        computed: {
          slideBounds: function() {
            var t = this.config,
              i = this.currentSlide,
              e = t.itemsToShow;
            return {
              lower: t.centerMode ? Math.ceil(i - e / 2) : i,
              upper: t.centerMode ? Math.floor(i + e / 2) : Math.floor(i + e - 1)
            };
          },
          trackTransform: function() {
            var t = this.config,
              i = t.infiniteScroll,
              e = t.vertical,
              r = t.rtl,
              n = t.centerMode,
              o = r ? -1 : 1,
              s = e ? this.slideHeight : this.slideWidth,
              a = e ? this.containerHeight : this.containerWidth,
              h =
                (e ? this.delta.y : this.delta.x) +
                o * ((n ? (a - s) / 2 : 0) - (i ? s * this.slidesCount : 0) - this.currentSlide * s);
            return e ? 'transform: translate(0, '.concat(h, 'px);') : 'transform: translate('.concat(h, 'px, 0);');
          },
          trackTransition: function() {
            return this.initialized && this.isSliding ? 'transition: '.concat(this.config.transition, 'ms') : '';
          }
        },
        watch: {
          group: function(t, i) {
            t !== i && (f.$off('slideGroup:'.concat(i), this._groupSlideHandler), this.addGroupListeners());
          },
          autoPlay: function(t, i) {
            t !== i && this.restartTimer();
          }
        },
        methods: {
          slideTo: function(t, i) {
            var e,
              r,
              n,
              o,
              s,
              a,
              h,
              l,
              c = this,
              u = !(1 < arguments.length && void 0 !== i) || i;
            this.isSliding ||
              t === this.currentSlide ||
              (this.$emit('beforeSlide', { currentSlide: this.currentSlide, slideTo: s }),
              (r = (e = this.config).infiniteScroll),
              (n = e.transition),
              (o = this.currentSlide),
              (s = r
                ? t
                : ((a = t), (h = this.trimStart), (l = this.slidesCount - this.trimEnd), Math.max(Math.min(a, l), h))),
              this.group && u && f.$emit('slideGroup:'.concat(this.group), t),
              (this.currentSlide = s),
              (this.isSliding = !0),
              window.setTimeout(function() {
                (c.isSliding = !1), (c.currentSlide = p(s, c.slidesCount));
              }, n),
              this.$emit('slide', { currentSlide: this.currentSlide, slideFrom: o }));
          },
          slideNext: function() {
            this.slideTo(this.currentSlide + this.config.itemsToSlide);
          },
          slidePrev: function() {
            this.slideTo(this.currentSlide - this.config.itemsToSlide);
          },
          initEvents: function() {
            null === this.defaults.rtl && (this.defaults.rtl = 'rtl' === getComputedStyle(this.$el).direction),
              this.$props.autoPlay && this.initAutoPlay(),
              this.config.mouseDrag && this.$refs.list.addEventListener('mousedown', this.onDragStart),
              this.config.touchDrag &&
                this.$refs.list.addEventListener('touchstart', this.onDragStart, { passive: !0 }),
              this.config.keysControl && this.$el.addEventListener('keydown', this.onKeypress),
              this.config.wheelControl &&
                ((this.lastScrollTime = o()), this.$el.addEventListener('wheel', this.onWheel, { passive: !1 })),
              window.addEventListener('resize', this.update);
          },
          getCurrentSlideTimeout: function() {
            var t = p(this.currentSlide, this.slidesCount);
            return l(this)[t].componentOptions.propsData.duration;
          },
          initAutoPlay: function() {
            var t = this;
            this.timer = new e(function() {
              if (t.isSliding || t.isDragging || (t.isHover && t.config.hoverPause) || t.isFocus || !t.$props.autoPlay)
                t.timer.set(t.getCurrentSlideTimeout());
              else {
                if (t.currentSlide === t.slidesCount - 1 && !t.config.infiniteScroll)
                  return t.slideTo(0), void t.timer.set(t.getCurrentSlideTimeout());
                t.slideNext(), t.timer.set(t.getCurrentSlideTimeout());
              }
            }, this.getCurrentSlideTimeout());
          },
          initDefaults: function() {
            (this.breakpoints = this.settings.breakpoints),
              (this.defaults = s({}, this.$props, this.settings)),
              (this.config = s({}, this.defaults));
          },
          update: function() {
            this.breakpoints && this.updateConfig(),
              this.updateWidth(),
              this.updateTrim(),
              this.$emit('updated', {
                containerWidth: this.containerWidth,
                containerHeight: this.containerHeight,
                slideWidth: this.slideWidth,
                slideHeight: this.slideHeight,
                settings: this.config
              });
          },
          updateTrim: function() {
            var t = this.config,
              i = t.trimWhiteSpace,
              e = t.itemsToShow,
              r = t.centerMode,
              n = t.infiniteScroll;
            if (!i || n) return (this.trimStart = 0), void (this.trimEnd = 1);
            (this.trimStart = r ? Math.floor((e - 1) / 2) : 0), (this.trimEnd = r ? Math.ceil(e / 2) : e);
          },
          updateWidth: function() {
            var t = this.$el.getBoundingClientRect();
            (this.containerWidth = t.width),
              (this.containerHeight = t.height),
              this.config.vertical
                ? (this.slideHeight = this.containerHeight / this.config.itemsToShow)
                : (this.slideWidth = this.containerWidth / this.config.itemsToShow);
          },
          updateConfig: function() {
            var i,
              e = this;
            Object.keys(this.breakpoints)
              .sort(function(t, i) {
                return i - t;
              })
              .some(function(t) {
                if ((i = window.matchMedia('(min-width: '.concat(t, 'px)')).matches))
                  return (e.config = s({}, e.config, e.defaults, e.breakpoints[t])), !0;
              }),
              i || (this.config = s(this.config, this.defaults));
          },
          restartTimer: function() {
            var t = this;
            this.$nextTick(function() {
              null === t.timer && t.$props.autoPlay
                ? t.initAutoPlay()
                : t.timer &&
                  (t.timer.stop(), t.$props.autoPlay && (t.timer.set(t.getCurrentSlideTimeout()), t.timer.start()));
            });
          },
          restart: function() {
            var t = this;
            this.$nextTick(function() {
              t.update();
            });
          },
          onDragStart: function(t) {
            (this.isTouch = 'touchstart' === t.type),
              (!this.isTouch && 0 !== t.button) ||
                ((this.startPosition = { x: 0, y: 0 }),
                (this.endPosition = { x: 0, y: 0 }),
                (this.isDragging = !0),
                (this.startPosition.x = this.isTouch ? t.touches[0].clientX : t.clientX),
                (this.startPosition.y = this.isTouch ? t.touches[0].clientY : t.clientY),
                document.addEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag),
                document.addEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd));
          },
          isInvalidDirection: function(t, i) {
            return this.config.vertical
              ? !!this.config.vertical && Math.abs(i) <= Math.abs(t)
              : Math.abs(t) <= Math.abs(i);
          },
          onDrag: function(t) {
            var i, e;
            this.isSliding ||
              ((this.endPosition.x = this.isTouch ? t.touches[0].clientX : t.clientX),
              (this.endPosition.y = this.isTouch ? t.touches[0].clientY : t.clientY),
              (i = this.endPosition.x - this.startPosition.x),
              (e = this.endPosition.y - this.startPosition.y),
              this.isInvalidDirection(i, e) ||
                ((this.delta.y = e), (this.delta.x = i), this.isTouch || t.preventDefault()));
          },
          onDragEnd: function() {
            var t,
              i,
              e,
              r = this.config.shortDrag ? 0.5 : 0.15;
            (this.isDragging = !1),
              this.config.vertical &&
                ((t = Math.round(Math.abs(this.delta.y / this.slideHeight) + r)),
                this.slideTo(this.currentSlide - a(this.delta.y) * t)),
              this.config.vertical ||
                ((i = (this.config.rtl ? -1 : 1) * a(this.delta.x)),
                (e = Math.round(Math.abs(this.delta.x / this.slideWidth) + r)),
                this.slideTo(this.currentSlide - i * e)),
              (this.delta.x = 0),
              (this.delta.y = 0),
              document.removeEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag),
              document.removeEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd),
              this.restartTimer();
          },
          onTransitionend: function() {
            (this.isSliding = !1), this.$emit('afterSlide', { currentSlide: this.currentSlide });
          },
          onKeypress: function(t) {
            var i = t.key;
            return (
              i.startsWith('Arrow') && t.preventDefault(),
              this.config.vertical
                ? ('ArrowUp' === i && this.slidePrev(), void ('ArrowDown' === i && this.slideNext()))
                : this.config.rtl
                ? ('ArrowRight' === i && this.slidePrev(), void ('ArrowLeft' === i && this.slideNext()))
                : ('ArrowRight' === i && this.slideNext(), void ('ArrowLeft' === i && this.slidePrev()))
            );
          },
          onWheel: function(t) {
            var i, e;
            t.preventDefault(),
              o() - this.lastScrollTime < 200 &&
                ((i = t.wheelDelta || -t.deltaY), -1 === (e = a(i)) && this.slideNext(), 1 === e && this.slidePrev()),
              (this.lastScrollTime = o());
          },
          addGroupListeners: function() {
            var i = this;
            this.group &&
              ((this._groupSlideHandler = function(t) {
                i.slideTo(t, !1);
              }),
              f.$on('slideGroup:'.concat(this.group), this._groupSlideHandler));
          }
        },
        created: function() {
          this.initDefaults();
        },
        mounted: function() {
          var t = this;
          this.initEvents(),
            this.addGroupListeners(),
            this.$nextTick(function() {
              t.update(),
                t.slideTo(t.config.initialSlide || 0),
                setTimeout(function() {
                  t.$emit('loaded'), (t.initialized = !0);
                }, t.transition);
            });
        },
        beforeDestroy: function() {
          window.removeEventListener('resize', this.update),
            this.group && f.$off('slideGroup:'.concat(this.group), this._groupSlideHandler),
            this.timer && this.timer.stop();
        },
        render: function(t) {
          var i = this,
            e = function(t) {
              var i = function(t) {
                  for (var i = l(this), e = i.length, r = 0, n = [], o = 0; o < e; o++) {
                    var s = i[o],
                      a = s.componentOptions && s.componentOptions.Ctor;
                    a &&
                      'HooperSlide' === a.options.name &&
                      ((s.componentOptions.propsData.index = r),
                      (s.data.key = r),
                      (s.key = r),
                      (s.data.props = h(h({}, s.data.props || {}), {}, { isClone: !1, index: r++ })),
                      n.push(s));
                  }
                  (this.slidesCount = n.length),
                    this.config.infiniteScroll &&
                      (n = (function(t, i) {
                        for (var e = [], r = [], n = i.length, o = 0; o < n; o++) {
                          var s = i[o],
                            a = u(t, s),
                            h = o - n;
                          (a.data.key = 'before_'.concat(o)),
                            (a.key = a.data.key),
                            (a.componentOptions.propsData.index = h),
                            (a.data.props = { index: h, isClone: !0 }),
                            e.push(a);
                          var l = u(t, s);
                          (h = o + n),
                            (l.data.key = 'after_'.concat(h)),
                            (l.componentOptions.propsData.index = h),
                            (l.key = l.data.key),
                            (l.data.props = { index: h, isClone: !0 }),
                            r.push(l);
                        }
                        return [].concat(e, c(i), r);
                      })(t, n));
                  return t(
                    'ul',
                    {
                      class: { 'hooper-track': !0, 'is-dragging': this.isDragging },
                      style: this.trackTransform + this.trackTransition,
                      ref: 'track',
                      on: { transitionend: this.onTransitionend }
                    },
                    n
                  );
                }.call(this, t),
                e = this.$slots['hooper-addons'] || [],
                r = t(
                  'div',
                  {
                    class: 'hooper-liveregion hooper-sr-only',
                    attrs: { 'aria-live': 'polite', 'aria-atomic': 'true' }
                  },
                  'Item '.concat(this.currentSlide + 1, ' of ').concat(this.slidesCount)
                ),
                n = [i].concat(c(e), [r]);
              return [t('div', { class: 'hooper-list', ref: 'list' }, n)];
            }.call(this, t);
          return t(
            'section',
            {
              class: { hooper: !0, 'is-vertical': this.config.vertical, 'is-rtl': this.config.rtl },
              attrs: { tabindex: '0' },
              on: {
                focusin: function() {
                  return (i.isFocus = !0);
                },
                focusout: function() {
                  return (i.isFocus = !1);
                },
                mouseover: function() {
                  return (i.isHover = !0);
                },
                mouseleave: function() {
                  return (i.isHover = !1);
                }
              }
            },
            e
          );
        }
      };
    var m = {
        name: 'HooperSlide',
        inject: ['$hooper'],
        props: {
          isClone: { type: Boolean, default: !1 },
          index: { type: Number, required: !0 },
          duration: { type: Number, default: null }
        },
        computed: {
          style: function() {
            var t = this.$hooper || {},
              i = t.slideHeight,
              e = t.slideWidth;
            return t.config.vertical ? 'height: '.concat(i, 'px') : 'width: '.concat(e, 'px');
          },
          isActive: function() {
            var t = this.$hooper.slideBounds,
              i = t.upper,
              e = t.lower;
            return this.index >= e && this.index <= i;
          },
          isPrev: function() {
            var t = this.$hooper.slideBounds.lower,
              i = this.$hooper.config.itemsToSlide;
            return this.index < t && this.index >= t - i;
          },
          isNext: function() {
            var t = this.$hooper.slideBounds.upper,
              i = this.$hooper.config.itemsToSlide;
            return this.index > t && this.index <= t + i;
          },
          isCurrent: function() {
            return this.index === this.$hooper.currentSlide;
          }
        },
        render: function(t) {
          var i = {
              'hooper-slide': !0,
              'is-clone': this.isClone,
              'is-active': this.isActive,
              'is-prev': this.isPrev,
              'is-next': this.isNext,
              'is-current': this.isCurrent
            },
            e = l(this);
          return t('li', { class: i, style: this.style, attrs: { 'aria-hidden': !this.isActive } }, e);
        }
      },
      v = {
        arrowUp: 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z',
        arrowDown: 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z',
        arrowRight: 'M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z',
        arrowLeft: 'M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z'
      },
      y = {
        name: 'HooperIcon',
        functional: !0,
        inheritAttrs: !0,
        props: {
          name: {
            type: String,
            required: !0,
            validator: function(t) {
              return t in v;
            }
          }
        },
        render: function(t, i) {
          var e,
            r = i.props,
            n = v[r.name],
            o = [];
          return (
            o.push(t('title', (e = (e = r.name).replace(/([A-Z]+)/g, ' $1')).charAt(0).toUpperCase() + e.slice(1))),
            o.push(t('path', { attrs: { d: 'M0 0h24v24H0z', fill: 'none' } })),
            o.push(t('path', { attrs: { d: n } })),
            t(
              'svg',
              { attrs: { class: 'icon icon-'.concat(r.name), viewBox: '0 0 24 24', width: '24px', height: '24px' } },
              o
            )
          );
        }
      },
      S = {
        inject: ['$hooper'],
        name: 'HooperProgress',
        computed: {
          currentSlide: function() {
            return p(this.$hooper.currentSlide, this.$hooper.slidesCount);
          },
          progress: function() {
            var t = this.$hooper.slidesCount - this.$hooper.trimStart - this.$hooper.trimEnd;
            return (100 * (this.currentSlide - this.$hooper.trimStart)) / t;
          }
        },
        render: function(t) {
          return t('div', { class: 'hooper-progress' }, [
            t('div', { class: 'hooper-progress-inner', style: 'width: '.concat(this.progress, '%') })
          ]);
        }
      };
    function $(r, n, t, o) {
      for (var s = [], i = 0; i < t; i++)
        !(function(t) {
          var i, e;
          s.push(
            (i = r)('li', [
              i(
                'button',
                {
                  class: { 'hooper-indicator': !0, 'is-active': (e = t) === n },
                  on: {
                    click: function() {
                      return o(t);
                    }
                  },
                  attrs: { type: 'button' }
                },
                [i('span', { class: 'hooper-sr-only' }, 'item '.concat(e))]
              )
            ])
          );
        })(i);
      return [r('ol', { class: 'hooper-indicators' }, s)];
    }
    var b = {
      inject: ['$hooper'],
      name: 'HooperPagination',
      props: { mode: { default: 'indicator', type: String } },
      computed: {
        currentSlide: function() {
          return p(this.$hooper.currentSlide, this.$hooper.slidesCount);
        },
        slides: function() {
          var t = this.$hooper.slides.map(function(t, i) {
            return i;
          });
          return t.slice(this.$hooper.trimStart, this.$hooper.slidesCount - this.$hooper.trimEnd + 1);
        }
      },
      render: function(t) {
        var i,
          e,
          r,
          n = this,
          o = this.$hooper.slidesCount,
          s =
            'indicator' === this.mode
              ? $(t, this.currentSlide, o, function(t) {
                  return n.$hooper.slideTo(t);
                })
              : ((i = t), (e = this.currentSlide), (r = o), [i('span', e + 1), i('span', '/'), i('span', r)]);
        return t('div', { class: { 'hooper-pagination': !0, 'is-vertical': this.$hooper.config.vertical } }, s);
      }
    };
    function w(t, i, e, r, n, o) {
      var s,
        a,
        h,
        l = n.isVertical,
        c = n.isRTL,
        u =
          e && e.length
            ? e
            : [
                t(y, {
                  props: {
                    name:
                      ((a = l),
                      (h = c),
                      r
                        ? a
                          ? 'arrowUp'
                          : h
                          ? 'arrowRight'
                          : 'arrowLeft'
                        : a
                        ? 'arrowDown'
                        : h
                        ? 'arrowLeft'
                        : 'arrowRight')
                  }
                })
              ];
      return t(
        'button',
        {
          class: (d((s = {}), 'hooper-'.concat(r ? 'prev' : 'next'), !0), d(s, 'is-disabled', i), s),
          attrs: { type: 'button' },
          on: { click: o }
        },
        u
      );
    }
    var T = {
      inject: ['$hooper'],
      name: 'HooperNavigation',
      computed: {
        isPrevDisabled: function() {
          return !this.$hooper.config.infiniteScroll && 0 === this.$hooper.currentSlide;
        },
        isNextDisabled: function() {
          return (
            !this.$hooper.config.infiniteScroll &&
            (this.$hooper.config.trimWhiteSpace
              ? this.$hooper.currentSlide ===
                this.$hooper.slidesCount - Math.min(this.$hooper.config.itemsToShow, this.$hooper.slidesCount)
              : this.$hooper.currentSlide === this.$hooper.slidesCount - 1)
          );
        }
      },
      methods: {
        slideNext: function() {
          this.$hooper.slideNext(), this.$hooper.restartTimer();
        },
        slidePrev: function() {
          this.$hooper.slidePrev(), this.$hooper.restartTimer();
        }
      },
      render: function(t) {
        var i = this,
          e = { isRTL: this.$hooper.config.rtl, isVertical: this.$hooper.config.vertical },
          r = [
            w(t, this.isPrevDisabled, this.$slots['hooper-prev'], !0, e, function() {
              return i.slidePrev();
            }),
            w(t, this.isNextDisabled, this.$slots['hooper-next'], !1, e, function() {
              return i.slideNext();
            })
          ];
        return t(
          'div',
          {
            class: {
              'hooper-navigation': !0,
              'is-vertical': this.$hooper.config.vertical,
              'is-rtl': this.$hooper.config.rtl
            }
          },
          r
        );
      }
    };
    (t.Hooper = g),
      (t.Icon = y),
      (t.Navigation = T),
      (t.Pagination = b),
      (t.Progress = S),
      (t.Slide = m),
      (t.addonMixin = { inject: ['$hooper'] }),
      (t.default = g),
      Object.defineProperty(t, '__esModule', { value: !0 });
  }),
  'object' == typeof exports && 'undefined' != typeof module
    ? i(exports, require('vue'))
    : 'function' == typeof define && define.amd
    ? define(['exports', 'vue'], i)
    : i(((t = t || self).Hooper = {}), t.Vue);
